# MEMOIRS

프로젝트를 개발하면서 생각해왔던 것과 어렵고 부족한 부분에 대해 정리한다.

### NestJS를 사용하는 이유

1. TypeScript 사용

자바스크립트를 어느 정도 익숙하게 다룰 수 있게 되면서 타입스크립트를 배워봤는데 타입을 곁들이게 될 시, 사전에 에러를 찾기 쉽다는 막강한 장점을 경험해보고서 기본으로 TypeScript를 채택한 NestJS를 사용해 보고 싶었다.

2. 아키텍처 문제

NodeJS를 사용하면 프로젝트의 구조를 사람마다 다르게 적용시키는 것이 가능하고 내가 나중에 다른 개발자들과 협업을 하게 될 때 프로젝트 구조를 설명해야 하는 일이 생긴다. NestJS를 사용하면 이러한 불편한 점을 개선할 수 있다고 생각했다. 기본적으로 NestJS는 NodeJS의 프레임워크로 프로젝트의 구조를 내맘대로 정하는 것이 아닌 이미 정해져 있는 룰을 따라야 하므로 프로젝트 구조에 대해 크게 신경쓰지 않아도 되는 점이 마음에 들었다.

3. OOP

자바스크립트를 공부하면서 OOP를 같이 사용하게 될 경험이 부족했는데 NestJS는 필요한 기능을 Module로 분리하여 필요한 곳에서 Dependency injection(의존성 주입)을 할 수 있도록 되어있다. 항상 절차적인 프로그래밍을 사용해왔던 것과 다르게 새로운 패러다임으로 프로그래밍 해보고 싶은 욕구가 있었다.

### NestJS에서 사용한 인증방식

NestJS 공식 문서에서 권장하는 인증방식은 Passport 이다. 비밀번호를 암호화하기 위해 bcrypt 라이브러리를 사용했고 유저가 로그인을 성공하게 될 시 Passport-Local 전략의 도움을 받아 request 객체에 user 필드를 부여받는다. 추후에 user 필드의 정보를 이용하여 로그인이 되었는지 확인할 수 있다. 인증은 이것만으로도 충분하다. 하지만 페이지를 이동하게 되면 user 필드의 정보가 모두 날아가버리는데 이는 HTTP 프로토콜이 Connenctionless(비연결상태)이기 때문이다. 유저가 페이지를 이동할 때마다 로그인을 해야한다면 아무도 이용하지 않게 될 겁니다. 이를 해결하기 위해 권한 인가(Authorization)를 해야 하는데 가장 기본적인 인가방식은 쿠키와 세션을 활용하는 방법이 있지만 NestJS에서 추천하는 방법은 JWT를 이용하는 것이다. 유저가 최초로 로그인을 성공했을 때 access token을 발급하고 그 이후로부터 HTTP 헤더의 베어러 토큰에 access token을 추가하여 페이지를 이동하거나 새로고침해도 헤더의 베어러 토큰에 들어있는 access token이 유효한지 검증하여 로그인이 계속해서 이어질 수 있도록 하는 방법이다. 이는 JWT 전략을 사용해야 가능한 것으로 만약 JWT 전략 없이 로그아웃을 진행하려 한다면 현재 로그인 되어있는 상태가 아니므로 에러가 발생할 것이다.
